-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.5)
-- from file main.cph, on 2020-05-08 at 00:10:27, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph,work;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;
use work.all;
use work.conv33_v1_globals.all;

entity d1lr_act is
   generic (
    v: signed(15 downto 0)
    );
  port (
    a_empty: in std_logic;
    a: in std_logic_vector(17 downto 0);
    a_rd: out std_logic;
    z_empty: in std_logic;
    z: in std_logic_vector(15 downto 0);
    z_rd: out std_logic;
    c_full: in std_logic;
    c: out std_logic_vector(17 downto 0);
    c_wr: out std_logic;
    zz_full: in std_logic;
    zz: out std_logic_vector(15 downto 0);
    zz_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end d1lr_act;

architecture FSM of d1lr_act is
    type t_enum12 is (S0,S1,S2,S3,S4);
    signal s : t_enum12;
    signal n_s : t_enum12;
    signal en_s : boolean;
begin
  comb: process(a, a_empty, z, z_empty, c_full, zz_full, s)
    variable p_p : signed(15 downto 0);
    variable p_z : signed(15 downto 0);
  begin
    -- z.rdy, s=S0 / p_z=z, s:=S0
    if z_empty='0' and s=S0 then
      p_z := from_std_logic_vector(z,16);
      z_rd <= '1';
      n_s <= S0;
      en_s <= true;
      c <= (others => 'X');
      c_wr <= '0';
      zz <= (others => 'X');
      zz_wr <= '0';
      a_rd <= '0';
    -- a.rdy, a=SoS, s=S0, c.rdy / rd(a), s:=S1, wr(c,SoS)
    elsif a_empty='0' and dc_s16.is_soS(a) and s=S0 and c_full='0' then
      a_rd <= '1';
      n_s <= S1;
      en_s <= true;
      c <= dc_s16.mk_soS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- a.rdy, a=EoS, s=S1, c.rdy / rd(a), s:=S0, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S1 and c_full='0' then
      a_rd <= '1';
      n_s <= S0;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- a.rdy, a=SoS, s=S1, c.rdy / rd(a), s:=S2, wr(c,SoS)
    elsif a_empty='0' and dc_s16.is_soS(a) and s=S1 and c_full='0' then
      a_rd <= '1';
      n_s <= S2;
      en_s <= true;
      c <= dc_s16.mk_soS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- a.rdy, a=EoS, s=S2, c.rdy / rd(a), s:=S3, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S2 and c_full='0' then
      a_rd <= '1';
      n_s <= S3;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- a.rdy, a=Data(p_p), s=S2, zz.rdy, c.rdy / p_p=a.data, s:=S2, wr(c,Data(v)), wr(zz,p_p)
    elsif a_empty='0' and dc_s16.is_data(a) and s=S2 and zz_full='0' and c_full='0' then
      p_p := dc_s16.get_data(a);
      a_rd <= '1';
      n_s <= S2;
      en_s <= true;
      c <= dc_s16.mk_data(v);
      c_wr <= '1';
      zz <= std_logic_vector(p_p);
      zz_wr <= '1';
      z_rd <= '0';
    -- a.rdy, a=EoS, s=S3, c.rdy / rd(a), s:=S0, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S3 and c_full='0' then
      a_rd <= '1';
      n_s <= S0;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- a.rdy, a=SoS, s=S3, c.rdy / rd(a), s:=S4, wr(c,SoS)
    elsif a_empty='0' and dc_s16.is_soS(a) and s=S3 and c_full='0' then
      a_rd <= '1';
      n_s <= S4;
      en_s <= true;
      c <= dc_s16.mk_soS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    -- z.rdy, a.rdy, a=Data(p_p), s=S4, zz.rdy, c.rdy / p_z=z, p_p=a.data, s:=S4, wr(c,Data(p_z)), wr(zz,p_p)
    elsif z_empty='0' and a_empty='0' and dc_s16.is_data(a) and s=S4 and zz_full='0' and c_full='0' then
      p_z := from_std_logic_vector(z,16);
      z_rd <= '1';
      p_p := dc_s16.get_data(a);
      a_rd <= '1';
      n_s <= S4;
      en_s <= true;
      c <= dc_s16.mk_data(p_z);
      c_wr <= '1';
      zz <= std_logic_vector(p_p);
      zz_wr <= '1';
    -- a.rdy, a=EoS, s=S4, c.rdy / rd(a), s:=S3, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S4 and c_full='0' then
      a_rd <= '1';
      n_s <= S3;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      zz <= (others => 'X');
      zz_wr <= '0';
      z_rd <= '0';
    else
      a_rd <= '0';
      z_rd <= '0';
      c_wr <= '0';
      zz_wr <= '0';
      c <= (others => 'X');
      zz <= (others => 'X');
      en_s <= false;
      n_s <= s;
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
      s <= S0;
    elsif rising_edge(clock) then
      if ( en_s ) then
        s <= n_s after 1 ns;
      end if;
    end if;
  end process;
end FSM;
