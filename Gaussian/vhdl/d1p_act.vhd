-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.5)
-- from file main.cph, on 2020-05-08 at 00:10:27, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph,work;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;
use work.all;
use work.conv33_v1_globals.all;

entity d1p_act is
   generic (
    v: signed(15 downto 0)
    );
  port (
    a_empty: in std_logic;
    a: in std_logic_vector(17 downto 0);
    a_rd: out std_logic;
    c_full: in std_logic;
    c: out std_logic_vector(17 downto 0);
    c_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end d1p_act;

architecture FSM of d1p_act is
    type t_enum7 is (S0,S1,S2);
    signal z : signed(15 downto 0);
    signal n_z : signed(15 downto 0);
    signal en_z : boolean;
    signal s : t_enum7;
    signal n_s : t_enum7;
    signal en_s : boolean;
begin
  comb: process(a, a_empty, c_full, s, z)
    variable p_p : signed(15 downto 0);
  begin
    -- a.rdy, a=SoS, s=S0, c.rdy / rd(a), s:=S1, wr(c,SoS)
    if a_empty='0' and dc_s16.is_soS(a) and s=S0 and c_full='0' then
      a_rd <= '1';
      n_s <= S1;
      en_s <= true;
      c <= dc_s16.mk_soS;
      c_wr <= '1';
      n_z <= z;
      en_z <= false;
    -- a.rdy, a=EoS, s=S1, c.rdy / rd(a), s:=S0, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S1 and c_full='0' then
      a_rd <= '1';
      n_s <= S0;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      n_z <= z;
      en_z <= false;
    -- a.rdy, a=SoS, s=S1, c.rdy / rd(a), s:=S2, wr(c,SoS), z:=v
    elsif a_empty='0' and dc_s16.is_soS(a) and s=S1 and c_full='0' then
      a_rd <= '1';
      n_s <= S2;
      en_s <= true;
      c <= dc_s16.mk_soS;
      c_wr <= '1';
      n_z <= v;
      en_z <= true;
    -- a.rdy, a=Data(p_p), s=S2, c.rdy / p_p=a.data, s:=S2, wr(c,Data(z)), z:=p_p
    elsif a_empty='0' and dc_s16.is_data(a) and s=S2 and c_full='0' then
      p_p := dc_s16.get_data(a);
      a_rd <= '1';
      n_s <= S2;
      en_s <= true;
      c <= dc_s16.mk_data(z);
      c_wr <= '1';
      n_z <= p_p;
      en_z <= true;
    -- a.rdy, a=EoS, s=S2, c.rdy / rd(a), s:=S1, wr(c,EoS)
    elsif a_empty='0' and dc_s16.is_eoS(a) and s=S2 and c_full='0' then
      a_rd <= '1';
      n_s <= S1;
      en_s <= true;
      c <= dc_s16.mk_eoS;
      c_wr <= '1';
      n_z <= z;
      en_z <= false;
    else
      a_rd <= '0';
      c_wr <= '0';
      c <= (others => 'X');
      en_z <= false;
      en_s <= false;
      n_z <= z;
      n_s <= s;
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
      s <= S0;
    elsif rising_edge(clock) then
      if ( en_z ) then
        z <= n_z after 1 ns;
      end if;
      if ( en_s ) then
        s <= n_s after 1 ns;
      end if;
    end if;
  end process;
end FSM;
