-- -------------------------------------------------------------------------------
-- This file has been automatically generated by the Caph compiler (version 2.8.5)
-- from file main.cph, on 2020-05-06 at 15:29:19, by <unknown>
-- For more information, see : http://caph.univ-bpclermont.fr
-- -------------------------------------------------------------------------------

library ieee,caph,work;
use ieee.std_logic_1164.all;
use caph.core.all;
use caph.data_types.all;
use ieee.numeric_std.all;
use work.all;
use work.sobel_globals.all;

entity asum_act is
   port (
    i1_empty: in std_logic;
    i1: in std_logic_vector(13 downto 0);
    i1_rd: out std_logic;
    i2_empty: in std_logic;
    i2: in std_logic_vector(13 downto 0);
    i2_rd: out std_logic;
    o_full: in std_logic;
    o: out std_logic_vector(13 downto 0);
    o_wr: out std_logic;
    clock: in std_logic;
    reset: in std_logic
    );
end asum_act;

architecture FSM of asum_act is
begin
  comb: process(i1, i1_empty, i2, i2_empty, o_full)
    variable p_p : signed(11 downto 0);
    variable p_q : signed(11 downto 0);
  begin
    -- i2.rdy, i2=SoS, i1.rdy, i1=SoS, o.rdy / rd(i2), rd(i1), wr(o,SoS)
    if i2_empty='0' and dc_s12.is_soS(i2) and i1_empty='0' and dc_s12.is_soS(i1) and o_full='0' then
      i2_rd <= '1';
      i1_rd <= '1';
      o <= dc_s12.mk_soS;
      o_wr <= '1';
    -- i2.rdy, i2=EoS, i1.rdy, i1=EoS, o.rdy / rd(i2), rd(i1), wr(o,EoS)
    elsif i2_empty='0' and dc_s12.is_eoS(i2) and i1_empty='0' and dc_s12.is_eoS(i1) and o_full='0' then
      i2_rd <= '1';
      i1_rd <= '1';
      o <= dc_s12.mk_eoS;
      o_wr <= '1';
    -- i2.rdy, i2=Data(p_q), i1.rdy, i1=Data(p_p), o.rdy / p_q=i2.data, p_p=i1.data, wr(o,Data((fabs(p_p)+fabs(p_q))>>1))
    elsif i2_empty='0' and dc_s12.is_data(i2) and i1_empty='0' and dc_s12.is_data(i1) and o_full='0' then
      p_q := dc_s12.get_data(i2);
      i2_rd <= '1';
      p_p := dc_s12.get_data(i1);
      i1_rd <= '1';
      o <= dc_s12.mk_data(SHIFT_RIGHT((fabs(p_p)) + (fabs(p_q)), 1));
      o_wr <= '1';
    else
      i1_rd <= '0';
      i2_rd <= '0';
      o_wr <= '0';
      o <= (others => 'X');
    end if;
  end process;
  seq: process(clock, reset)
  begin
    if (reset='0') then
    elsif rising_edge(clock) then
    end if;
  end process;
end FSM;
